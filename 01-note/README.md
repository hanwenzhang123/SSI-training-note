---
title: HTML, CSS, JavaScript (Note Part1)
---

## React, Redux (Note Part2)
https://github.com/hanwenzhang123/frontend-note/blob/main/02-note/README.md

## JS Cheatsheet (Note Part3)
https://github.com/hanwenzhang123/frontend-note/blob/main/03-note/README.md

## Miscellaneous (Note Part4)
https://github.com/hanwenzhang123/frontend-note/blob/main/04-note/README.md

## Boilerplate Code (Note Part5)
https://github.com/hanwenzhang123/frontend-note/blob/main/05-note/README.md

## Table of Contents
- [HTTP](#http)
- [HTML](#html)
- [CSS](#css)
- [Sass](#sass)
- [JavaScript](#javascript)
- [ES6](#ES6)
- [Promise](#Promise)
- [Funtion](#Function)
- [Scope](#Scope)
- [Closure](#Closure)
- [This](#this)
- [DOM Event](#DOM-event)

## HTTP

#### What is HTTP?
- HTTP stands for Hyper Text Transfer Protocol, used for transferring data over a network
- HTTP is the foundation of data communication between web clients (often browsers) and servers (often computers in the cloud) for the World Wide Web.
- Communication between client computers and web servers is done by sending HTTP Requests and receiving HTTP Responses
- HTTP is stateless, every request is completed independent

#### HTTP methods
- GET: requests data from a specified resource
- POST: send data to server to create/update a resource - always contains HTTP request body to send to the data (more secure)
- PUT: means "insert, replace if already exists", similar to POST, but same PUT request multiple times will always produce the same result
- HEAD: is almost identical to GET, but without the response body.
- PATCH: is making partial changes to an existing resource.
- DELETE: deletes the specified resource.

#### HTTP response status codes
- Informational responses (100–199)
- Successful responses (200–299)
- Redirection messages (300–399)
- Client error responses (400–499)
- Server error responses (500–599)

#### HTTP Headers
- headers as key:value involving -> method, path, protocol
- general: request url, request method, status code, remote address, referrer policy
- response: server, set-cookie, content-type, content-length, date, status
- request: cookies, accept-xxx, content-type, content-length, authorization, user-agent, referrer

#### request & response
- HTTP requests are generated by a user's browser as the user interacts with web propertie (clicks on a hyperlink, the browser will send a series of "HTTP GET" requests)
- HTTP requests all go to either an origin server or a proxy caching server, and that server will generate an HTTP response. 
- HTTP responses are answers to HTTP requests.
- Browser - Internet - Server - Internet - Broswer

#### HttpRequest & HttpResponse
- HttpRequest Attributes: method, path, version of protocol, headers(content)
- HttpResponse Attributes: http version of protocol, status code, status message, headers(content)
- content-type in the headers - what kind of data you are sending/receiving based on this request

#### application/x-www-form-urlencoded 
- The content-type describes form data that is sent in a single block in the HTTP message body (in the headers)

#### HTTPS
- Hyper Text Transfer Protocol Secure, data sent is encrypted through SSL/TLS
- Install SSL certificate on web host, SSL (secure socket layer) TLS (transport Layer Security)

#### Google.com
- once you enter Google.com, the browser extracts the domain name from the URL, sends request via http protocol (like agreement based on TCP/IP) which connect to TCP/IP first before reaching to server
- The browser checks the cache for a DNS record to find the corresponding IP address of google.com. If requested URL not exist, DNS request fails, returns nothing
- The browser initiates a TCP connection with the server, and sends an HTTP request to the web server.
- The server handles the request and sends back a HTTP response.
- The browser displays the HTML content (for HTML responses, which is the most common).

#### cookie, sessionStorage and localStorage
- `sessionStorage` - client side, use when you need to store somthing temporary, will only be accessible while the window is open, expires when tab closes, 5MB Min
- `localStorage` - client side, store data on the client computer, save key/value pairs in web browser, store data with no expiration date, last until the user deletes it, 5MB Min
- `cookie` - primarily for server-side, stored data needs to be sent back to server, expiration can be set from either server-side or client-side when manually set, 4KB Max

#### local storage
```js
let now = new Date() || new Date().getTime();
let userData = JSON.parse(localStorage.getItem('storedData'))
localStorage.setItem('key', 'value')
localStorage.getItem('key')
localStorage.removeItem('key')
localStorage.clear()
```

- Handle expiration of storage on the browser
```js
localStorage.setItem(key, JSON.stringify(item))
```

- setWithExpiry and getWithExpiry
```js
setWithExpiry("myKey", inputSet.value, 5000)
const value = getWithExpiry("myKey")
valueDisplay.innerHTML = value
```

#### cookie
```js
`document.cookie`
```


## HTML

#### What does a DOCTYPE do?
- when we have a doctype, it is an "information" to the browser about what document type to expect. 
- Not case-sensitive.

#### href & target in `<a>` tag.
- `_blank` (new tab) and `_self` (current tab)
- `<a href=“https://www.youtube.com/” target="_blank"></a>`

#### div and span
- `<div>` - anything can be putting within a div, it is a block element
- `<span>` - like a div but only for inline container, which div is block level element

#### why using semantic tags?
- we want to know what does it exactly means in the HTML, we can know it directly by its name 
- `<div>` is too broad, we do not know what it really means. 
- semantic elements carry accessibility by itself, proper reading
- `<article><aside><details><figcaption><figure><footer><header><main><mark><nav><section><summary><time>`
  
#### a11y 508 accessibility
- computer accessibility, for people with disability using screen reader 
- mac machine, window, 3rd party tool, it will read out the web contents for you
- you want to have your website good with accessibility features

#### video and audio
- the text between the tags only appears when video/audio is not working
```html
<video width="320" height="240" controls>
  <source src="movie.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

<audio controls>
  <source src="horse.mp3" type="audio/mpeg">
  Your browser does not support the audio tag.
</audio>
```

#### form elements
```html
<form action="/action.php" method="post" id="form">
  <label for="name">Name:</label>
  <input type="text" id="name" name="name">
  <input max="99" min="1" name="age" step="1" type="number" value="18" />
  <select name="gender">
	<option selected="selected" value="male">Male</option>
	<option value="female">Female</option>
  </select><br /> 
  <input checked="checked" name="newsletter" type="radio" value="daily" />
  <textarea cols="20" name="comments" rows="5">Comment</textarea>
  <input name="terms" type="checkbox" value="terms" />
  <input type="submit" value="submit" />
  <input type="reset">
</form>
<button form="form">Send</button>
```

#### What is the `<meta>` tag in the `<head>` tag?
- `<meta>` - metadata about an HTML document, is data (information) about data. 
- `<meta>` tags always go inside the `<head>` element, and are used to specify character set, page description, keywords, author, and viewport settings.
- `<meta>` is important for SEO (search engine optimization). we do not visually see any of the code in the browser, but the browser will analyze the information.

#### SEO (Search engine optimization)
- The process of improving the quality and quantity of website traffic to a website or a web page from search engines.

#### Improving SEO
- Publish relevant, authoritative content. 
- Update your content regularly. 
- Use Metadata. 
- Use alt tags describe imagines.
- Improve title tags.

#### Character Encoding
- To display an HTML page correctly, a web browser must know which character set to use.
- Charset a table of unique numbers assigned to different characters like letters, numbers and other symbols like ASCII 128 different characters
- HTML5 charset standard: `<meta charset="UTF-8">`

#### `<html>``<body>` and `<header>``<footer>`
- An HTML should only one `<html>` and `<body>` tag in the document
- You can use multiple `<header>` and `<footer>` elements in a webpage
- they represent a header and footer of a section, like every `<section>` and `<article>` also can contain these two tags

#### `<canvas>` vs `<svg>`
- both elements are used to draw two-dimensional graphics on a web page.
- like a container for graphics, unlike imagines, there is no impact on enlarging the graphics.
- use JavaScript to actually draw like `setAttribute("fill", "green");`

#### What is the `<iframe>` tag
- an inline frame is used to embed/display a web page within a web page.
- `<iframe src="https://www.w3schools.com"></iframe>`

#### Difference between `<script>`, `<script async>` and `<script defer>`.
- `<script>` - HTML parsing is blocked, the script is fetched and executed immediately, HTML parsing resumes after the script is executed.
- `<script async>` - in parallel to HTML parsing and executed as soon as it is available (potentially before HTML parsing completes)
- `<script defer>` - in parallel to HTML parsing and executed when the page has finished parsing, ensuring that the HTML is fully parsed before executing. There's not much difference in putting a normal `<script>` at the end of `<body>`.

[[↑] Back to top](#table-of-contents)


## CSS

#### specificity
- !important - overrides any other declarations
- id selector `#`
- class selector `.`
- Type selectors `p`
- Universal selector `*`

#### px, em and rem
specify sizes or lengths of elements using various units of measure
- px: You get what you asked for. Pixels may be good at spacing and layout, but are not good fit for font-size.
- em: Relative to the parent element
- rem: Relative to the root element (HTML tag), do not care about the parent

#### Three ways to insert CSS
- external CSS (better choice, a separate css file)
- internal CSS (putting css directly in the html page using style tag, higher priorty)
- inline CSS (not recommended, highest priority, overriding other ways, not reusable)

#### margin/padding
- 4 value order: top right bottom left 
- 3 value order: top left&right bottom
- 2 value order: top&bottom left&right

#### The CSS Box Model
- margin, border, padding, content
- goes from outside to the inside

#### reset css
- `* { margin:0; padding:0; box-sizing: border-box }`
- reset: consistent baseline, more control over the styling of everything.
- normalize: cross-browser consistency without completely losing the default styles with CSS standards.

#### box-sizing property
- `content-box`: using content as the basis, default, only care about your content
- `border-box`: using border as the basis, like when we put a padding

#### what is margin collapse?
- Top and bottom margins collapse into a single margin when it comes in contact with one another
- Take the greater value. Only top and bottom margins!

#### display
- 'block' - full width, force a line break
- 'inline' - just for inline, you can set margin and padding left-right, but not top-bottom, no width and height
- 'inline-block' - allow elements to sit to left & right, top & bottom margins and padding, height and width

#### position
- `static` - default, follow the flow into the page as it normally would
- `relative` - almost same as static, but you can change the position relatively to the docs (its normal position), can even overflow (the ability to use z-index)
- `absolute` - other elements render as this absolute element does not even exist, relative to the nearest positioned ancestor 
- `fixed` - fixed based on the doc and always stick to where it is
- `sticky` - combination of relative and relative stick to the position based on the users scroll position

#### relative vs absolute
- `position: relative` - starts from where the element would be in the normal document flow
- `position: absolute` - removed from the normal document flow, placed in an exact location where you tell it to go on the page, relative to the nearest positioned ancestor (focus on the parent). 

#### z-index
- set the order of a positioned overlapping element, larger z-index cover smaller one.

#### combinators
- descendant selector (space) - all elements that are descendants of a specified element.
- child selector (>) - all elements that are the children of a specified element
- adjacent sibling selector (+) - immediate, an element that is directly after another specific element
- general sibling selector (~) - all elements that are next siblings of a specific element

#### pseudo-class
- class like specific state, this specific state will happen under what kind of condition
- `a:hover` - mouse over; `a:visited/:focus` - visited, mouse focused
- `:nth-child()` - pseudo-class, value like odd, even, a specific number etc

#### pseudo-element
- referring specific location for that element
- `p::first-line/::last-letter` `::after/::before`
- capitalize first letter: `p:first-letter { text-transform:capitalize; }`

#### invisible from the page
- `display:none` - does not occupy space or consume clicks, hide the whole element and remove that from layout, gone from the DOM tree, disappear from UI
- `visibility:hidden` - occupies space, but does not consumes clicks, hides an element but take up the same space as before
- `opacity:0` - occupies space and consumes clicks, create transparency or fade effect

#### center both vertically and horizontally using flexbox
- `display: flex`
- `justify-content: center` - horizontally or vertically depends on the main axis
- `align-items: center` - center in the middle 

#### flexbox
- With a parent element set to flex, all direct child elements in the container automatically becomes flexible items. (one dimension layout)
- initially all flex items in one row (`flex-direction`) with same stretch height (`align items`: layout for all items on the main axis line)
- `justify-content`: layout based on main axis, `align-content`: for multilines, `flex-wrap`: wrap items instead of shrinking, `align-self`: for individual item
- `display: flex`, `flex: flex-grow, flex-shrink, flex-basis` with all default 1, `order` to change item order, `gap` to change gap

#### grid system
- two dimensions layout with rows and columns, direct children of the grid container automatically become grid items
- `display: grid; grid-template-column: 2fr 1fr; grid-auto-rows: minmax(1, auto); grid-column/column: start/end(-1); row-start/end; grid-gap;`

#### flex and grid
- flex: for alignment -> small design to implement, align elements, content-first design
- grid: for layout -> complex design to implement, a gap between block elements, overlap elements, layout-first design

#### media queries
- for responsive design, change the styling once the size reaches a certain value
- `<source srcset="img_smallflower.jpg" media="(max-width: 600px)">`
- `@media only screen and (max-width: 600px) {}`

#### what is image sprite?
- a collection of images put into a single image (by combining images in a single file) -> reduce the number of HTTP server requests for image resources
- A web page with many images can take a long time to load and generates multiple server requests, using image sprites will reduce the number of server requests

#### SVG icon and icon font
- icon fonts are treated as a piece of text by the browser
- SVGs are treated as an image/graphic with built in semantic elements that makes it accessible to screen reader 

#### BEM Naming Convention
- Block: describes its purpose ("What is it?" — menu or button) - it doesn't depend on other page components
- Element: describes its purpose ("What is this?" — item, text, input) `block-name__element-name` with a double underscore `(__)` - can't be used separately without the parent entity (the block)
- Modifier: describes its appearance ("What size?" or "Which theme?"), its state ("How is it different from the others?"), and its behavior ("How does it behave?"), like `directions_left-top` with a single underscore `(_)`

#### Cross Browser Compatibility
- check browser support: `caniuse.com` or use `CrossBrowserTesting` for testing
- The ability of a website, application or script to support various web browsers identically.
- For example, we can check if CSS animation features support equally under various web environments

[[↑] Back to top](#table-of-contents)


## Sass

#### What is Sass?
- CSS can get messy when the code gets large, Sass is an extension of CSS3 that does things CSS do not
- for exmple, adding nesting rules, mixins, variables, selector inheritance, functions etc.
- Broswer reads CSS but Sass, we write Sass code to Sass file and compile the code to css code using npm or Watch Sass in VS Code.

#### Syntax
- Sass syntax: no curly braces, no semicolons
- SCSS syntax: with curly braces, with semicolons
- `@import "./header";` - import the sub-scss in style.scss
- naming for the sub-file: _heaader.scss

#### Key Features for Sass
- Variables: `$primaryBtm` for reusable values; `&:hover``&&:after` for psuedo
- Nesting: to nest selectors inside of one another, allowing us to write less code
- Operators: for mathematical operations right inside of CSS `100%-20%`
- Mixins: `@mixin name{}` `@include name()` define style that can be re-used in the CSS 
- Functions: similar to mixins, with the difference that they produce a value that can be used `@mixin name($parameter){}`
- Partials and imports: `@import` to write CSS in different files and importing them all into one single file 
- Extends: `@extend` allow a selector to inherit the styles of another one, you can overwrite the style
- Placeholder: styles that were meant to be extended `%placeholder``@extend %placeholder`
- Control directives: for writing complex code using conditionals and loops

#### Mixin function in Sass
```css
@mixin flexCenter ($direction){
  display:  flex;
  justify-content: center;
  align-items: center;
  flex-direction: $direction;
}
header{
  @include flexCenter(column);
}
```

#### Sass comments
- regular CSS starts with `/* comments…*/`
- SASS: the single line comments `//` and the multiline CSS comments with `/* */`.

#### Data Types that SassScript supports
1. Numbers ( eg; 1,5 ,10px)
2. Strings of texts ( g., “foo”, ‘bar’, etc.)
3. Colors (blue, #04a3f9)
4. Booleans (true or false)
5. Nulls (e.g; null)
6. List of values, separated by space or commas (g., 1.5em, Arial, Helvetica etc.)
7. Maps from one value to another (g., ( key 1: value1, key 2: Value 2))

#### How interpolation is used in Sass?
- Define an element in a variable and interpolate it inside the Sass code
- It is useful when you keep your modules in separate files.

#### the meaning of DRY-ing out a mixin?
- splitting it into dynamic and static parts.
- the dynamic mixin is the one that the user actually going to call
- the static mixin is the pieces of information that would otherwise get duplicated. 

#### what Sass Maps is and what is the use of Sass Maps?
A structured data in a hierarchical way and not just a bunch of variables, helps in organizing the code.
- It is very useful when dealing with layers of elements
- It can be helpful in color management when there is long list of different color and shade
- Use icon map for various social media icons for example: facebook: ‘\e607’ or twitter: ‘\e602’
- Unlike other programming libraries, Sass map will consist only of code that is going to be used

[[↑] Back to top](#table-of-contents)


## JavaScript

#### what is V8?
Internal JavaScript engine built in Chrome.

#### JS Engine
takes code as input and undergoes 3 major phases: PARSING, COMPILATION and EXECUTION.
1. Parsing - code is broken down into array of tokens and convert it into AST (Abstract Syntax Tree).
2. Compilation - decides whether JS is interpreted or compiled language, can use interpreter along with compiler to make it JIT (Just in time) compiled language.
3. Execution - Interpreter and compiler are in sync with execution phase making use of Memory heap and Call stack.

#### compilation
- JIT compilation: Generating machine code during runtime.
- AOT compilation: In this compiler takes piece of code (which is supposed to be executed later) and tries to optimize it.

#### "use strict" Mode
It gives you less tolerate to errors, put on top of your program

#### data type
- `primitive` variable stores the values, refer by value
- `non-primitive` object points to a reference (memory location of the value), not the value itself
```js
typeof 42 	//number
typeof "abc"	//string
typeof true	//boolean
typeof Boolean(1) //boolean
typeof undefined  //undefined
typeof null 	//object (js built-in error)
typeof {"a": 1}	//object
typeof [1, 2, 3] //object
typeof function hello(){} //function
```

#### false values
false, 0, -0, 0n, "", null, undefined, and NaN

#### =, ==, ===
- `=` - assignment operator, which sets the variable on the left of the = to the value of the expression that is on its right
- `==` - comparison operator, which transforms the operands having the same type before comparison `2=='2'`
- `===` - strict equality comparison operator, which returns false for the values which are not of a similar type  `2==='2'`

#### concat - coercion
It is recommended to use `+` and `+=` which are better/faster over `.concat()` for performance reason.
```js
//automatically convert to string; number + -> concat
console.log(1+"2")     //12
console.log(2+"1")     //21
console.log(1+2+"1")    //31

//no concat, will automatically convert to math operation
console.log(5-"2")  //3
console.log(5-"a") //NaN - Not a number, invalid operation, no ascii code in JS
```

#### coercion comparison
```js
42 == "42"; // true 
1 == true; // true

var x = "10"; 
var y = "9";
x < y;      // true
```

#### dynamic casting
```js
typeof 42 	//number
typeof "abc"	//string
typeof Boolean(1) //boolean
let a = 1
console.log(typeof !a) //boolean, check the 2nd value
console.log(!1) //false
let a = 1
console.log(typeof !!a) //true, !! - double negation
let a = 0
console.log(typeof !!a)  //false, boolean will be false
!!""    //false, nothing in there
!!" " //true, there is a space, it is not empty
!!{}    //true - it is object, empty box but there is something

null == false    //false
undefined == false  //false
null == undefined   //true
null === undefined  //false
console.log()    //undefined

|| or
&& and
! not
? optional chaining
+ numeric representation 
console.log(1 || 0)    //1
console.log(1 && 0)    //0
console.log(1 || 2 || 3) //1 - OR - looking for the first TRUCY value, otherwise return last element
console.log(1 && 2 && 3) //3 - AND - looking for the first FALSY value, if not any, return last element
```

#### Error
- `ReferenceError` occurs when you try to use a variable that doesn't exist at all.
- `TypeError` occurs when the variable exists, but the operation you're trying to perform is not appropriate for the type of value it contains
- `SyntaxError` occurs when trying to interpret syntactically invalid code.
- `RangeError` occurs when a number "out of range" has occurred.
- `Runtime Error` is an error that occurs during the running of the program, also known as the exceptions - "bugs"
- `Complier Error` occurs before any part of your code runs, interpreter can not understand at any point in your program,

#### Error Handling (exception catching)
- when you do something that may break your program
- `try` lets you test a block of code for errors.
- `catch` lets you handle the error.
- `throw` lets you create custom errors. (execution of the current function will stop, the statements after throw won't be executed, and control will be passed to the first catch block in the call stack. If no catch block exists, the program will terminate.)
- `finally` lets you execute code, after try and catch, regardless of the result.

[[↑] Back to top](#table-of-contents)


## ES6

#### New Features of ES6
1. let const vs var 
2. arrow function
3. template literal 
4. default params
5. destructuring
6. spreading (...) /rest (...rest)
7. promises
8. class syntax
9. async/await(ES7)

#### var and let/const 
- var -issue with value hoisting, put things on the top, scope to the function - old way
- let/const - not accessible before the line we declare them, scope to the block 
- let: re-assign value; const: no re-assign allowed, we can not change pointer
```js
console.log(a);    //undefined - variable exist, not able to access to the value
var a = 1;
console.log(b);   //ReferenceError - b is not exist, temporal dead zone
let b = 1;
```

#### Scoping
```js
for(let i = 0; i < 5; i++){	//let - block scope, let i gives us a new i for each iteration, 
    setTimeout(()=>{
        console.log(i)  //0 1 2 3 4
    }, 500);
}
```
```js
for(var i = 0; i < 5; i++){	//var - function scope
    setTimeout(()=>{
        console.log(i)  //5 5 5 5 5
    }, 500);
} 
```
new `j` created each iteration, which gets a copy of the value of `i` at this moment 
```js
var keeps = [];
for (var i = 0; i < 3; i++) {
    let j = i;
    keeps[i] = function keepEachJ(){
        return j; 
    };
 } 
keeps[0](); //0 
keeps[1](); //1 
keeps[2](); //2
```

#### Hoisting
- Variable hoisting means the JavaScript engine moves the variable declarations to the top of the script. 

#### Temporal Dead Zone
- accessing a let or const variable before its declaration (within its scope) causes a ReferenceError.
- between the creation of a variable’s binding and its declaration, is called the temporal dead zone.

#### Describe Arrow Function
- simple syntax, less code, if within one line, implicitly returned without the use of return keyword
- does not have its own "this" to be referred to the current object
- does not need to bind functions
- use lexical scoping — 'this' refers to it's current surrounding scope and no further.

Disadvantage of Arrow Function
- does not have "arguments" which access to all the inputs parameters
- can never be used as constructor functions
- can never be invoked with the new keyword
- a prototype property does not exist for an arrow function.

```js
var obj = {
	name: "mic",
	getName: function(){
		return this.name    //"this" belongs to the obj that calls the function
	}
	getName2: () => {    
		return this.name    //arrow function does not have its own "this", "this" here means the Window    
	}
};
console.log(obj.getName())    //mic
console.log(obj.getName2())   //undefined
```

#### default params
```js
const genParam = () => {
  console.log("Called");
  return 5;
};

function f(x, y = genParam()) {
  console.log(x, y);
}

f(1); //1, 5
f(1,  9); //1, 9
f(1, undefined);  //1, 5 - no difference from f(1);
f(1, null); //1, null - null considered to be a valid input
```

#### destructuring
```js
const obj = { x: 1 };
const { x: otherX } = obj;  //re-naming, will be stored in the new name
console.log(otherX)   //1
//console.log(x)   //no good, referenceError, x is not defined.

//in array, order matters
const arr = [1, 2];
let [z, q] = arr;
console.log(q, z);  //2 1
[q, z] = [z, q];
console.log(q, z);  //1 2 - reassign the value

//Re-naming
const obj = { x: 1 };
const { x: newVariable } = obj;   //just about the syntax, change the name x to newVariable
// const newVariable = obj.x    //x as the key to get the value and stores in the variable
console.log(newVariable)  //1
```

#### spreading (...)
```js
const obj = { x: 1 };
const newObj = { ...obj };
console.log(newObj)    //{ x: 1 }
console.log(obj === newObj)   //false - shallow clone

const newObj = { ...obj, y: 2 }; // addition
const newObj = { ...obj, x: 2 }; // overwrite

const s = "Hello";
const sArr = [...s];
console.log(sArr) //["H", "e", "l", "l", "o"]
console.log(sArr.length); //5
```

#### rest (...rest)
```js
function func(a) {
  console.log(a); //1
}
func(1);

function func(a, ...rest) {   //rest element must be the last parameter
  console.log(rest); //[2, 3, 4, 5, 6, 7]
}
func(1, 2, 3, 4, 5, 6, 7);

function func(a, b, ...rest) {
  console.log(rest); //[3, 4, 5, 6, 7]
  console.log(arguments[0]); //1 - arguments is for everything in the params, it returns array like object, but does not carry any array methods
}
func(1, 2, 3, 4, 5, 6, 7);
```

## Promise

#### sync vs async
- sync code, code that is going to execute right away, one expression at a time.
- async code, will not get executed right away, but sometime in the future, the next expression runs while the previous finishes up.

#### Asynchronous JS
- JS uses callback, promise, async-await to implement asynchronous patterns.

#### Promise(event loop, task scheduling)
- JS is a single-threaded language, use promise to handle async operation, avoid callback hell which is a chained nested code
- A Promise is a proxy for a value not necessarily known, when the promise is created, that represents WORK that needs to be done at some point.

#### 3 phrases -> pending, fulfilled, rejected
- chain .then() to do something, and/or .catch() to catch error
- we can chain more .then(), return promise, execute only after the main thread is done

```js
const promise = new Promise((resolve, reject) => {
  //do a thing, possibly async, then...
  if(/* everything turned out fine */){
  	resolve("Stuff worked!")
  } else {
  	reject(Error("It broke!"))
  }
});

promise.then((resolve) => { console.log(resolve) });	//Stuff worked!
```
```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 300);
});

myPromise.then((resolve) => {
  console.log(resolve);
}).catch((err) => {
  console.log(err);
})
```

#### `Promoise.all([])`
- run promises in parallel, create an array of promises and then use `Promise.all(promisesArray)`.
- send all promises, returns a single Promise that resolves to an array of the results of the input promises
- will reject immediately upon any of the input promises rejecting => if one fails, all fail
- `Promise.racce()` works similar as `Promoise.all()` but return a single value whichever return the first

```js
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then((values) => {
  console.log(values);	 //return an array - [3, 42, "foo"] that contains all the value
});
```

#### async/await
- cleaner style handling asynchonous tasks, return promise, await takes a pause, then returns its result -> must with async keyword
- easier for promise chaining (not faster), better for accessing value in the scope with assigned variable, and output of function2 is dependent on the output of function1
- start with async function, replace .then() with await, use try catch for error handling, async function can be dynamic like mongodb update/delete endpoints

`main thread (console.log) > micro (promise, async/await-pauses) > macro (timeout, interval)`

[[↑] Back to top](#table-of-contents)


## Function

#### Parameters vs Arguments
```js
function counter(x, y){ //x & y are parameter console.log(x+y);
	//do something
}
var a = 10, b = 2;
counter(a, b); //a & b are argument
```

#### Callbacks
- a function passed into another function as an argument 
- this function will be executed later only after this another function has finished executing
- JS is synchronous single threaded language but through use of Callback functions we can perform async task.
- great for async calls, handle something after something else has been completed, enforce the order of operation that we want (Eg, Event listeners make use of this.)

```js
function greeting(name) {
  alert('Hello ' + name);
}
function processUserInput(callback) {
  var name = prompt('Please enter your name.');
  callback(name);
}
processUserInput(greeting);
```

#### First class function
- In JS, is called first class function, aka, first class citizens.
- Callback is also a first class function going by this definition because it is also passed as an argument. 
- The ability of functions to be: 
1. Assigned to variable
2. Passed as argument to another function
3. Returned from another function

#### Unary Function
- a function that accepts exactly one argument. It stands for a single argument accepted by a function.
- `const unaryFunction = a => console.log (a + 10); // Add 10 to the given argument and display the value`

#### First Order Function
- a function that doesn’t accept another function as an argument and doesn’t return a function as its return value.
- `const firstOrder = () => console.log ('I am a first order function!');`

#### Higher Order Function
- a function that accepts another function as an argument or returns a function as a return value or both.
- map, reduce, filter, find, etc
```js
const firstOrderFunc = () => console.log ('Hello, I am a First order function');
const higherOrder = (ReturnFirstOrderFunc) => ReturnFirstOrderFunc();
higherOrder(firstOrderFunc);
```

#### Currying
- a nested function that takes multiple arguments one at a time, the last function returns the result based on all the argument
- convert a function with multiple arguments into several functions of a single arguments in sequence.
- we do not change the functionality of a function, we just change the way it is invoked
- useful in the context of function composition 
- `const addNumber = (a) => (b) => (c) => a+b+c;`

#### Composition
- a function called in another function
- You can chain higher-order functions into composition

#### Page Redirection
- `window.open('{url}','_blank');` - open in a new window
- `function redirect() { window.location='{URL}' };` - `setTimeout(redirect, 1000);`

#### Popup Boxes
- alert: `window.alert("sometext");`
- prompt: `window.prompt("sometext","defaultText");`
- confirm: `window.confirm("somtext")` ok and cancel -> return boolean

#### Function Declaration vs Expression
- Function declarations load before any code is executed 
- Similar to the var statement, function declarations are hoisted to the top of other code. 
- Function expressions load only when the interpreter reaches that line of code. 
- Function expressions aren’t hoisted, which allows them to retain a copy of the local variables from the scope where they were defined.
```js
myF()
function myF(){
	console.log("My Function")    //it is okay to under the function declaration using keyword function
}
myF()
const myF = function(){
	console.log("My Function")  //ReferenceError, no good with function expression, can not access function initialization, myF() failed directly
}
myF()
var myF = function(){
	console.log("My Function")  //TypeError, no good, myF is not a function, var myF = undefined;
	//when you try to execute myF, it is good, it is there, but it triggers the function which is undefined, that it breaks the rule. 
}
```

Benefits of Function Expressions:
- As closures
- As arguments to other functions
- As Immediately Invoked Function Expressions (IIFE)

#### IIFE - immediate invoked function expression 
- runs as soon as it is defined, invoke immediately
- variables declared in the function expression will not be available outside the function
- primary purpose: data privacy because any variables declared within the IIFE cannot be accessed by the outside world.

contains two major parts: 
1. function expression within the Grouping Operator () 
2. immediately invoke the function ()

examples
- `(function() {  /* */ })()`
- `(() => {  /* */ })()`

```js
for (var i = 1; i <= 3; i++) {		//var makes i stays in the function scope
    (function(index) {	//inner function gets local copy of outer function arguement
        setTimeout(function() { alert(index); }, i * 1000);	//having a copy of i in it
    })(i);	//using a self-invoking function, IIFE, each iteration created a new scope for each iteration
}
```

## Scope

#### lexical & global
- Lexical Scope: a variable defined outside a function can be accessible inside another function defined after the variable declaration (Whenever execution context is created, a lexical environment is also created)
- Global Scope: contains, and is visible in, all other scopes (Global object (in browsers, it is called window) which is referenced by ‘this’.)

#### block vs function
- `var` is function scope.
- Function scope is within the function, each function creates a new scope
- `let` and `const` are block scope.
- Block scope is within curly brackets, variables declared inside a { } block cannot be accessed from outside the block

#### "The Principle of Least Privilege" (POLP) 
- encourages us to use block (and function) scoping to limit the scope exposure of variables. 
- least exposure helps keep code understandable and maintainable, and helps avoid many scoping pitfalls.

#### scoping pitfalls
- name collision: the identifier comes from one shared scope (like the global scope)
- unexpected behavior: expose variables/functions whose usage is otherwise private to a piece of the program
- unintended dependency: expose variables/functions unnecessarily which invites other developers to use and depend on those otherwise private pieces

#### shadowing
- Shadowing: a variable is declared in a certain scope having the same name defined on its outer scope

```js
var a = 99; 
{
    let a = 10;		//let is block scope
    let b = 11;
    const c = 200;
    console.log(a);	//10
}
console.log(a);	//99
```

#### illegal shadowing
- Illegal Shadowing: we can shadow var variable by let variable, but cannot do shadow let variable by var variable

```js
let a = 10;
{ 
  var a = 20;	//SyntaxError: Identifier 'a' has already been declared
}
//var is not scoped to the block it's in, it's scoped to the containing function. 
//if there is no containing function, it ends up in the global scope. 
//it conflicts with the let a declaration which is also in the global scope.
```

[[↑] Back to top](#table-of-contents)


## Closure

#### what is closure
- a function retured by another function that still has access to its outer scope variable
- ability to remember and access scope even if was called from another scope
- used to enable data privacy, but cons -> may cause memory leak
```js
function makeCounter(){
    let count = 0;      //private variable for keeping data private and safe
    			//value by the function will be saved as it will be needed by the inner function, not for garbage collection
    return function(){
        count++
        return count;
    };
}
const counterFunc = makeCounter();
console.log(counterFunc()); //1
console.log(counterFunc()); //2
const newFunc = makeCounter();  //a new function, variabel value start over
console.log(newFunc());  //1
console.log(newFunc());  //2
```

#### Closure Definition
- Closure is observed when a function uses variable(s) from outer scope(s) even while running in a scope where those variable(s) wouldn't be accessible.
- Closure encapsulates the body of code together with the lexical scope. 
- Closure is most common when working with asynchronous code, such as with callbacks.

#### Closure Requirements
- Must be a function involved
- Must reference at least one variable from an outer scope
- Must be invoked in a different branch of the scope chain from the variable(s)

#### Disadvantages of Closures
Closure is associated directly with memory consumption. Hence, it leads to high consumption of memory, if lot of closures are created, since the allocated memory are not garbage collected till program expires.

#### Garbage Collector
It is a program in the browser/JS Engine which is responsible for freeing up the memory which are unutilised.

[[↑] Back to top](#table-of-contents)


## This

#### "this" keyword
- entirely dependent on how it is called
- refers to the object that the function is a property of. 
- the value will always depend on the object that is invoking the function.

#### bind vs apply vs call
`bind()`
- The bind() method creates a new function used to provide a proper "this" reference to the function
- it returns a new bound function, does not call the function, but refer to it that you can execute later

`apply()/call()`
- same, just the different way to put in the parameter: call => comma; apply => array
- directly triggers itself, call it right now, unlike bind, not yet to call

#### this in functions
- "this" behaves differently in arrow functions compared to a regular function.
- `this` in `regular function`, `this` belongs to function, it binds its own value, like person.fullName(), "this" refers to the left to the '.' 
- `this` in `arrow function`, `this` DOES NOT belong to arrFunc, it is outside of the function, arrow functions don't bind their own this value

#### this examples
```js
//1. this IN method, this -> object owner
const person = {
    firstName: 'Viggo',
    lastName: 'Mortensen',
    fullName: function () {
        return `${this.firstName} ${this.lastName}`     //just like ${person.firstName} ${person.lastName}, this -> object owner
    },
    
//     fullName: () => {        //"this" has nothing to do with the scope where the function is created, it has to do with how the function is executed
//         console.log(this);  // "this" refers to Window, if we do person.fullName() which means Window.fullName() - it will be undefined
//         return `${this.firstName} ${this.lastName}`
//     },       //when we are using arrow function, "this" will be jumping out to the original block which will be global scope
    
    shoutName: function () {
        setTimeout(() => { 
            //keyword 'this' in arrow functions refers to the value of 'this' when the function is created
            console.log(this);       //"this" refers to the person Object
            console.log(this.fullName())
        }, 3000)
        
//     shoutName: function () {
//         setTimeout(function () => {      //we have to use arrow function here instead
//             console.log(this);       // "this" refers to Window object here
//             console.log(this.fullName())     //this.fullName is not a function - it has to do with the execution context
//         }, 3000)        
    }
}
person.fullName()   //"this" refers to the left to the '.' here is the person

//2. this IN function, this -> global on browser -> Window
function a() {
    console.log(this)   //Window, this -> global
}
a()     //Window
console.log(this)      //Window

//2.1 this IN function, strick mode, this -> undefined
function a() {
    "use strict"
    console.log(this) 
}
a();   //undefined

//3. this IN event, this -> HTML element that received the event
<button onClick="this.style.display"="none">
    click to remove me!
</button>
```

[[↑] Back to top](#table-of-contents)


## DOM Event

#### What is DOM?
- DOM stands for Document Object Model, it represents an independent document with a logical tree of objects, and it is the render path of elements in a website
- DOM dynamically access and update the content, structure, and style of a document.
- DOM is the HTML (describes the document and its content) but represent in JS (interacts with DOM to makes changes/add features to the HTML 
- => if we change DOM, HTML changes; if we change HTML, DOM will change too (broswer keeps in sync)

#### JS mechanism (how to handle the sync and async code)
- The event loops behind the browser handles the sync and async JavaScript code, like when JS engine that built in the browser (for chrome is V8) runs JS code, because JS is a single threaded language, the code will be read line by line, and stores the memory in the heap, and push the function call to the callstack. If it is async function code, it will be then pushed to the web API instead to wait for the condition to be met while the call stack keeps running as first in last out, and garbage collects the variables that are no longer in use. Once the async code in the web API is ready to run, it will then be pushed to the Message Queue. When there are no functions to run in the call stack, the Event Loop will take the first event from the Queue and will push it to the Call Stack to run.

#### Event loop: 
- In JS there are 3 types of memory: `stack` used for functions call, `heap` for each of the objects, `queue` — setTimeout. 
- JS engine executes the function stack first. If the stack is empty, it pops the event from queue. If the event queue has another function call, it pushes it to stack and executes it again until it is empty. This is called event loop;

#### Web API
- All the code execution is done inside callstack, which is present in JS engine, which in turn is in browser.
- Browser has some added functionalities like, Local storage, Timer, Address field, etc.
1. SetTimeout()
3. DOM APIs
4. Fetch()
5. LocalStorage
6. Console
7. Location
 
#### Asynchronous web API
- Q. Are only asynchronous web API callbacks, registered in the web API environment?
- A. YES, the synchronous callback functions like what we pass inside map, filter, and reduce aren't registered in the Web API environment. It's just those async callback function that are registered.

#### DOM Methods
- Adding Elements: `body.append("Hello World")`; `body.append(div)`; `.appendChild(div)`;
- Creating Elements: `document.createElement("div")`; 
- Modifying Element Text: `div.innerText="Hello World"` (how HTML works, and looks at CSS like invisible); `div.textContent="Hello World"` (exact text content copy pasted in HTML);
- Modifying Element HTML: `div.innerHTML="<strong>Hello World</strong>"`;
- Removing Elements: `div.remove()`; `.removeChild(span)`;
- Modifying Element Attributes: `span.getAttribute("id")`; `span.setAttribute("title", "Hello")`; `span.removeAttribute("id")`;
- Modifying Data Attributes: `console.log(span.dataset.test)`; `span.dataset.newName="hi"`;
- Modifying Element Classes: `span.classList.add("new-class")`; `span.classList.remove("hi")`; `span.classList.toggle("hi2", false)`;
- Modifying Element Style: `span.style.backgroundColor="red"`;
- Select: `document.querySelector("div")`;
- Make Interactive: `btn.addEventListener()`;
- Change CSS: Style Property

#### Event Handling
- Events are triggered by the user, the browser, or something else to make changes to HTML, CSS and JavaScript
- Detect and Respond to an event using JavaScript
- identify a DOM node to monitor
- identify the event you want to respond to
- create a function to run when the event is triggered

#### addEventListener()
- `element.addEventListener(event, function, useCapture)`
- addEventListener() method attaches an event handler to the specified element, anaymous function are not supported in AddEventListener call, will cause error.
- removeEventListener() method to remove an event handler that has been attached with the addEventListener() method.
- event: A String that specifies the name of the event like "click", "mouseover", "keyup"
- function: Specifies the function to run when the event occurs
- useCapture: Optional. A Boolean specifies whether the event should be executed in the capturing (true) or bubbling phase (false).

#### Event.preventDefault()
- prevent the browser from executing the default action of the selected element. 
- Clicking on a "Submit" button, prevent it from submitting a form
- Clicking on a link, prevent the link from following the URL

#### Event.stopPropagation() 
- prevents further propagation of the current event in the capturing and bubbling phases. 
- By default, events are bubbled. These propagation of event is expensive and we can stop it by calling, .stopPropagation() method.

#### Event Propagation
- like a deeper ocean goes to the layer one by one travel through the DOM tree to arrive at its target and what happens to it afterward

Three phases in order are:
1. the `event capturing phase` - top to the botton - outermost to inner - click outter which will trigger the inner one. 
2. the `target phase` - all the listeners registered on the event target will be invoked
3. the `event bubbling phase` - buttom to the top - innermost to outer - click the inner one, the outter one will also be clicked

#### Event Delegation
- Allow you to avoid adding event listeners to specific nodes; instead, the event listener is added to one parent. 
- Instead of attaching the event listeners directly to the buttons, you delegate listening to the parent `<div id="buttons">`. 
- When a button is clicked, the listener of the parent element analyzes the bubbling event and catches on a matched child element (recall the event propagation).

#### pros & cons
PROS of event delegation:
1. Improves Memory
2. Write less code
3. DOM manipulation

CONS of event delegation:
1. All events are not bubbled up, like, blur, resize, etc.

[[↑] Back to top](#table-of-contents)
